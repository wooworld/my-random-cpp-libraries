// BEGINNING OF FILE ----------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
/// @file TSP-ucts.cpp
/// @author Gary Steelman
/// @edit 24 Jan 2010
/// @brief Function definitions for the uniform cost tree search algorithm.
/// @note Assignment 2.
///////////////////////////////////////////////////////////////////////////////

#include "TSP-ucts.h"
#include "vector.h"
#include "state.h"
#include <vector>
#include <cstdlib>
#include <functional>
#include <queue>
#include <ctime>

using namespace std;

TSPUCTS::TSPUCTS():m_numCities(0), m_totalDistance(0), m_changed(true) {}

TSPUCTS::TSPUCTS( const Matrix<double>& m ):m_graph(m), m_totalDistance(0), m_changed(true) {

  srand( time( NULL ) ); 
  m_numCities = m.width();
  State initState( m.width(), rand()%m.width(), 0 );
  m_cState = initState;
  
}

const Matrix<double>& TSPUCTS::getGraph() const {
  
  return m_graph;
  
}

unsigned int TSPUCTS::getNumCities() const {

  return m_numCities; 
  
}

void TSPUCTS::setGraph( const Matrix<double>& m ) {

  srand( time( NULL ) ); 
  m_graph = m;
  m_numCities = m.width();
 
  State initState( m.width(), rand()%m.width(), 0 );
  m_cState = initState;
  
  m_totalDistance = 0;
  m_changed = true;
  
  return;
  
}

const State& TSPUCTS::currState() const {
  
  return m_cState;
  
}

void TSPUCTS::setCurrState( const State& s ) {

  m_cState = s;
  m_changed = true;
  
  return;
  
}

void TSPUCTS::solve() {

  //We'll only recalculate the solution if we haven't done it already
  if ( m_changed == true )
  {
    //For holding the nodes of the search
    priority_queue<State, deque<State>, greater<State> > frontier;
    
    //For holding nodes already expanded on
    deque<State> explored;
    
    //Set the first node
    frontier.push( m_cState );
    
    //Holds the states generated by the successor function
    vector<State> avail;
   
    while ( !frontier.empty() )
    {    
      m_cState = frontier.top();
      
      if ( isGoal( m_cState ) )
        break;

      frontier.pop();
      avail.clear();
      successor( m_cState, avail );
      
      //In the case we've reached a state where all cities have been visited
      if ( avail.empty() )
      {
        avail.push_back( m_cState );
        avail.back().m_path.push_back( m_cState.m_path[0] );
        avail.back().setCost( m_cState.cost() + m_graph[m_cState.m_path[0]][m_cState.location()] );
        avail.back().setLocation( m_cState.m_path[0] );
      }
      
      explored.push_back( m_cState );
      
      bool append = true;
      
      //Push all generated States onto the search queue, but only if we
      //haven't seen them before. Takes time, but stops the algorithm from
      //using gigabytes of memory.
      for ( unsigned int i = 0; i < avail.size(); i++ ) {
      
        append = true;
        
        for ( unsigned int j = 0; j < explored.size(); j++ ) {
        
          if ( avail[i] == explored[j] )
            append = false;
        }
        
        if ( append )
          frontier.push( avail[i] );
      }
    } 
    
    m_solution = m_cState.m_path;
    m_totalDistance = m_cState.cost();
    m_changed = false;
  }

  return;
  
}

void TSPUCTS::successor( const State& iState, vector<State>& avail ) { 
  
  //For each city in the current state
  unsigned long int visitedSize = iState.getVisited().size();
  for ( unsigned long int i = 0; i < visitedSize; i++ )
  {
    //If that city has not been visited
    if ( !iState.getVisited()[i] )
    {
      //Then push it into the list of available states to move to
      avail.push_back( iState );
      
      //And update it to reflect what would happen after we move there
      avail.back().setVisited(i);
      avail.back().setLocation(i);
      avail.back().m_path.push_back(i);
      avail.back().setCost( iState.cost() + m_graph[iState.location()][avail.back().location()] );
    }
  }
  
  return;
  
}

const Vector<unsigned int>& TSPUCTS::get_solution() const {

  return m_solution;

}

double TSPUCTS::distanceTraveled() const {

  return m_totalDistance;
  
}

//Returns if the state is a goal state
bool TSPUCTS::isGoal( const State& s ) const
{
  //If we aren't in the initial city, there's no way we're done
  if ( s.location() != s.m_path[0] )
    return false;  
  
  //Check each city for visited status
  unsigned long int visitedSize = s.getVisited().size();
  for ( unsigned long int i = 0; i < visitedSize; i++ )
    if ( s.getVisited()[i] == false )
      return false;
  
  return true;
}

// END OF FILE ----------------------------------------------------------------
