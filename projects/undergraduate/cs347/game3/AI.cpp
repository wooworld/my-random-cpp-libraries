// BEGINNING OF FILE ----------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
/// @file AI.cpp
/// @author Gary Steelman, CS347 AI Team
/// @edit 7 Mar 2010
/// @brief Function definitions for the AI for playing Backgammon.
/// @note Though the main call is QSHTABIDM, the quiescence search and history
///   tables are not yet implemented. 
///////////////////////////////////////////////////////////////////////////////

#include "AI.h"
#include "backgammon_state.h"
#include <queue>
#include <ctime>
#include <cfloat>
#include <climits>
#include <iostream>
#include <functional>
#include <algorithm>

using namespace std;

/******************************** global constants ***************************/
//These bounds are still being developed as h_state_eval is.
const double _Lower = -100.0;   //The lower bound of values generated by h_state_eval
const double _Upper = 300;      //The upper bound of values generated by h_state_eval

const int _DepthLimit = 50;     //The maximum number of layers to search
const int _QSDepthLimit = 5;    //The maximum number of layers to search extra

const double _nInf = DBL_MIN;   //Negative infinity
const double _Inf = DBL_MAX;    //Positive infinity
const double _MyEpsilon = 1.0e-10; //For Use in the Chance node star1 search
const int _GEN_TYPE = 0;        //0 = Perform QSHTABIDM search
                                //1 = Perform RANDOM search

/****************************** global variables *****************************/
//For statistical purposes only!
double _PRUNES = 0;         //For counting the number of prune actions
double _MOVES = 0;          //For counting the total number of moves generated

clock_t _start;             //For recording the start of the turn
clock_t _now;               //For getting the number of milliseconds elapsed
double _time_allot = 0;     //For holding how much time we can use this turn

bool _ALL_STOP = false;     //For telling us to stop going deeper

//Run on turn 1 before run(), the board is still set up just fine though
void AI::init() { return; }

bool AI::run()
{
  /************************************ setup ********************************/
  //Set the beginning time of this turn
  _start = clock();
  
  //Show the board
  displayBoard();
  
  //Get values at each point on the board, each die value, sort the l2h dice,
  //mark each die unused, generate a backgammon_state using the information
  deque<int> initial_board(26);
    for ( int i = 0; i < 26; i++ )
      initial_board[i] = getPoint(i);
  
  deque<int> dice;
    for ( int i = 0; (i < 4) && (getDie(i) != 0); i++ )
      dice.push_back( getDie(i) );
    sort( dice.begin(), dice.end(), less<int>() );
  
  deque<bool> diceUsed(dice.size(), false);  
  
  backgammon_state curr_state;
    curr_state.m_board = initial_board;
    curr_state.m_dice = dice;
    curr_state.m_dice_used = diceUsed;
    curr_state.m_bear_off = false;
    curr_state.m_player = getPlayerID();
    curr_state.m_score = 
      ( curr_state.m_player == 0 ) ? ( player0Score() ) : ( player1Score() );
  
  /************************ generate and execute moves ***********************/
  if ( _GEN_TYPE == 0 )
  {
    //QSHTABIDM 
    //Time-Limited Iterative-Deepening Depth-Limited Star1 
    //  with History Table & Quiescence Search
    
    //Figure out how much time we want to spend this turn
    set_time( curr_state );
    
    backgammon_state best_move;
    
    for ( int d = 1; d <= _DepthLimit; d++ )
    {
      cout << "DEPTH: " << d << endl;
      
      best_move = QSHTABIDM( curr_state, d, _QSDepthLimit, _nInf, _Inf );
      
      cout << "\nDEPTH COMPLETE: " << d << endl;
      cout << "\nTOTAL NUMBER OF PRUNES: " << _PRUNES << endl;
      cout << "\nTOTAL NUMBER OF MOVES: " << _MOVES << endl;
      
      if ( _ALL_STOP == true )
      {
        break;
      }
      
      //cin.get();
    }

    if ( best_move.m_move.empty() ) 
    {
      cout << "\n>>No legal moves generated :(" << endl;
      return true;
    }
    
    else 
    {
      make_move( best_move );
    }
  }
  
  //RANDOM
  else if ( _GEN_TYPE == 1 )
  {
    deque<backgammon_state> legal_moves;
    gen_moves( curr_state, legal_moves );
    
    cout << "Full-state moves generated: " << legal_moves.size() << endl;
    
    if ( legal_moves.empty() ) 
    {
      cout << "\n>>No legal moves generated :(" << endl;
      return true;
    }
    
    else 
    {
      //Randomly choose a move from the set of legal_moves.
      srand( time( NULL ) );
      
      make_move( legal_moves[rand() % legal_moves.size()] );
    }
  }
  
  return true; //End our turn
  /***************************** end move execution ****************************/
}

/*****************************************************************************/
/***************************** generate moves ********************************/
/*****************************************************************************/
void AI::gen_moves( const backgammon_state& s, deque<backgammon_state>& r )
{    
  //The die value we're currently using
  int dieVal = 0;
  
  //How many points to loop through to generate moves
  int LSVal = 0;
  int LEVal = 26;
  
  //Generation of half-state flags. True = need to use this die.
  bool use_0 = true;
  bool use_1 = true;
  
  //For jumping forward spaces in times of bearing off and needing to
  int advance = 0;
  
  //The current state we're using to generate moves from
  backgammon_state curr_state = s;
  
  //Keep going until we generate all the states necessary
  while ( true )
  {
    cout << "\n---------------------------------------------------" << endl;
    
    if ( curr_state.m_dice.size() == 2 )
    {
      cout << "-Singles mode-" << endl;

      //If we need to generate half states using 0 or 1
      if ( (use_0 == true) || (use_1 == true) )
      {
        //generate half-states using die 0
        if ( use_0 == true )
        {
          cout << "  Generation using only 0" << endl;
          dieVal = curr_state.m_dice[0];
          use_0 = false;
          curr_state.m_dice_used[0] = true;
          //curr_state.m_dice_used[1] = false;
        }
        
        //generate half-states using die 1
        else
        {
          //Means we tried to generated using the smaller die first and couldn't
          //Which means we may have a situation in which we need to use 
          //only the largest die
          //if ( r.empty() && (largest_only == false) )
          //{
            //largest_only = true;
          //}
          
          cout << "  Generation using only 1" << endl;
          dieVal = curr_state.m_dice[1];
          use_1 = false;
          curr_state.m_dice_used[0] = false;
          curr_state.m_dice_used[1] = true;
        }
        
      } //End if choosing which die to use first
      
      //use_0 == false and use_1 == false, so we've used both of them
      //but were unable to generate any moves, sucks for us
      else if ( r.empty() )
      {
        cout << "  tried to gen full states, but failed" << endl;
        
        if ( !curr_state.m_move.empty() )
        {
          cout << "falling back to previous state because it still has moves" << endl;
          r.push_back( curr_state );
        }
        
        return;
      }
      
      //Or if we've generated half-states already, and we need to now
      //generate full-states from the half-states
      //else if ( !r.empty() && continue_generation( r.front() ) )
      else if ( continue_generation( r.front() ) )
      {
        //Turn the first half-state into a full-state
        
        //if (used_both)
        //  r.pop_front();
          
        curr_state = r.front();
        r.pop_front();
        
        //check to see if we can only use 1 die from this state, and make it
        //be the larger of the two die
        // if we were able to generate a state, we need to make sure thatit's using
        //   either both die or just the higher one
        
        //If this state requires generation using die 0 to become full
        if ( curr_state.m_dice_used[0] == false )
        {
          cout << "  Generation using 0, already did 1" << endl;
          dieVal = curr_state.m_dice[0];
          curr_state.m_dice_used[0] = true;
        }
        
        //else if it requires generation using die 1 to become full
        else
        {
          cout << "  Genration using 1, already did 0" << endl;
          dieVal = curr_state.m_dice[1];
          curr_state.m_dice_used[1] = true;
        }
        
      } // End generation on first element of r
      
      //If we hit this it means that we don't need to use only 1
      //and we don't need to use only 0, and we don't need to continue 
      //generation, which means we have reached a set of full-states
      //And our possible subsequent states are stored in the (r)esult set
      else if ( !continue_generation( r.front() ) )
      {
        cout << "finished generating moves" << endl;
        return;
      }
      
      else
      {
        cout << "something terrible has happened" << endl;
        return;
      }
      
    } // End generation decisions for singles
    
    //This means we are in doubles mode, meaning quarter-state generations
    //are necessary instead of half-state generations.
    //This code seems to catch errors in our number of die available, too.
    else 
    {
      cout << "-Doubles Mode-" << endl;
      //cin.get();
      if ( r.empty() && curr_state.m_dice_used[0] == true )
      {
        cout << "tried to gen a state before, and it didn't work. suck" << endl;
        if ( !curr_state.m_move.empty() )
        {
          cout << "falling back to previous state because it still has moves" << endl;
          r.push_back( curr_state );
        }
        
        return;
      }
      
      //Initially curr_state = the passed state. So we want to skip generation
      //using the (r)esulting set on the first pass, and only use the first part
      //of the (r)esulting set on the 2nd-4th passes.
      else if ( !r.empty() && continue_generation( r.front() ) )
      {
        cout << "  Generating using a result set state" << endl;
        
        //if (used_both)
        //  r.pop_front();
          
        curr_state = r.front();
        r.pop_front();
      }
      
      //If we hit this it means we're either on the first pass
      //or we have generated at least one state, and all the states we need to
      else if ( !r.empty() && !continue_generation( r.front() ) )
      { 
        return;
      } 
      
      //Mark the next die used for curr_state
      //cout << " curr_State.m_dice.size() = " << curr_state.m_dice.size() << endl;
      for ( int dm = 0; dm < curr_state.m_dice.size(); dm++ )
      {
        if ( curr_state.m_dice_used[dm] == false )
        {
          //cout << "  Generation using " << dm << endl;
          
          curr_state.m_dice_used[dm] = true;
          
          break;
        }
      }
      
      dieVal = curr_state.m_dice[0];
      
    } // End generation decisions for doubles
    
    //Now, if in the current state we have a piece on the bar we need to move
    //we'll limit the j loop to only generate states for the bar point
    //instead of generating for all points
    //If player X and we need to move off the bar
    //cout << "  working on bar moves" << endl;
    if ( (curr_state.m_player == 0) && (curr_state.m_board[25] < 0) )
    { 
      cout << "  Detected bar move for X!" << endl;
      LSVal = 0;
      LEVal = 1;
      //cin.get();
    }
    
    //If player O and we need to move off the bar
    else if ( (curr_state.m_player == 1) && (curr_state.m_board[0] > 0) )
    {
      cout << "  Detected bar move for O!" << endl;
      LSVal = 0;
      LEVal = 1;
      //cin.get();
    }
    
    //Otherwise we don't need to move off of the bar, so we generate a full
    //range of moves for all checkers on all points. 
    else
    {
      LEVal = 26;
      
      bear_check( curr_state );

      //Limits our check of the board to the home quadrants if we're trying to
      //bear off, so we don't waste time checking the rest of the board
      LSVal = ( curr_state.m_bear_off == true) ? ( 19 ) : ( 0 );
    }    
    /************************* end generation decisions **********************/
    
    /***************************** generate moves ****************************/
    curr_state.print();
    cout << "\n  dieVal = " << dieVal << "; LVal = " << LSVal << ", " << LEVal << endl;
    cout << "  ";
    
    //We run through each triangle on the board and see if we can make a move
    //off of that spot
    //bool norm_move = true;
    bool j_edit = false;
    for ( int j = LSVal; j < LEVal; j++ )
    {
      j_edit = false;
      if ( curr_state.m_player == 1 )
        cout << j << " ";
      else
        cout << 25-j << " ";

      //add condition for going off the end of the board lol
      //case:
      // 0 0 0 2 6 3->exit, using a 5
      if ( curr_state.m_bear_off == true )
      {
        //Do a check backward to see if we can even bear off with this pie
      
        //Calculate the furthest back point that's less than the value
        //of the die from the exit on the board. This is the point we can
        //bear off using this die from, and no other point
        //advance = advance_to( curr_state, dieVal );
        
        //case where furthest point is closer to goal than die roll is
        //Pushes j forward a space or two so that we can bear off from
        //the furthest point
        //j += ( 25-j != dieVal ) ? ( (dieVal - furthest) ) : ( 0 );
        
        //if ( (curr_state.m_player == 0) && (curr_state.m_board[25-j] < 0) && (25-j > dieVal) )
        if ( (curr_state.m_player == 0) 
          && (25-j-dieVal < 1)
          && (curr_state.m_board[25-j] == 0)
          && ( !check_back( curr_state, 25-j, dieVal ) )
          )
        {
          advance = advance_to( curr_state, dieVal );
          //cout << "xf(" << dieVal - advance << ") ";
          j+=(dieVal - advance);
          j_edit = true;
          
          cout << ":" << 25-j << " ";
        }
        
        //else if ( (curr_state.m_player == 1) && (curr_state.m_board[j]) && ( j+dieVal != 25) )
        else if ( (curr_state.m_player == 1) 
          && (j+dieVal > 24)
          && (curr_state.m_board[j] == 0)
          && ( !check_back( curr_state, j, dieVal ) )
          )
        {
          advance = advance_to( curr_state, dieVal );
          cout << "of(" << advance - (25-dieVal) << ") ";
          j+=(advance - (25-dieVal));
          j_edit = true;
        }
      }
      
      //call checkback, but only if the current die roll is further away 
      //than our current position
        
      //If we're player X and we own the spot
      if ( (curr_state.m_player == 0) && (curr_state.m_board[25-j] < 0) )
      {
        cout << "+ ";
        //If the spot we would move to is on the board and open
        //OR if we would be trying to bear off and we move off the board
        //Basically, legal move check
        if ( ((25-j-dieVal > 0) && (curr_state.m_board[25-j-dieVal] <= 1))
          || ((curr_state.m_bear_off == true) && (25-j-dieVal < 1)) )
        {
          
          
          //If we're trying to bear off, check special cases
          if ( (curr_state.m_bear_off == true) && (25-j-dieVal < 1) )
          {
            //Means we're not allowed to bear off from this point
            if ( check_back( curr_state, 25-j, dieVal ) == true )
            {
              cout << "cb ";
              continue;
            }
          }
          
          cout << "+ ";
          _MOVES++;

          //Make a copy of the current state
          r.push_back( curr_state );
          
          //Remove a checker from the current spot
          r.back().m_board[25-j]++;

          //If our move keeps us on the board
          if ( 25-j-dieVal > 0 )
          {
            //If we hit the opponent, move their checker to the bar
            if ( curr_state.m_board[25-j-dieVal] == 1 )
            {
              r.back().m_board[25-j-dieVal]--;
              r.back().m_board[0]++;
            }
            
            //Place our checker on the new spot
            r.back().m_board[25-j-dieVal]--;
          }
          
          //Moved off the board
          else
          {
            r.back().m_score++;
          }
          
          //Record the move. If 25-j-dieVal < 0, it means we bear off with this move
          r.back().m_move.push_back(25-j);
          r.back().m_move.push_back(25-j-dieVal);

          //If we pushed j forward, move it back
          if ( j_edit == true )
          {
            j-=( dieVal - advance );
            j_edit = false;
          }
        }
      } 
      
      //If we're player O and O owns the spot
      else if ( (curr_state.m_player == 1) && (curr_state.m_board[j] > 0) )
      {
        //If we're trying to bear off, check special cases
        if ( (curr_state.m_bear_off == true) && (j+dieVal > 24) )
        {
          //Means we're not allowed to bear off from this point
          if ( check_back( curr_state, j, dieVal ) == true )
          {
            cout << "cb ";
            continue;
          }
        }
      
        cout << "~ ";
        //If the spot we would move to is on the board and open
        //OR if we would be trying to bear off and we move off the board
        if ( ((j+dieVal < 25) && (curr_state.m_board[j+dieVal] >= -1))
          || ((curr_state.m_bear_off == true) && (j+dieVal > 24)) )
        {
          cout << "~ ";
          _MOVES++;
          
          //Make a copy of the current state
          r.push_back( curr_state );
          
          //Remove a checker from the current spot
          r.back().m_board[j]--;

          //If our move keeps us on the board
          if ( j+dieVal < 25 )
          {
            //If we hit the opponent, move their checker to the bar
            if ( curr_state.m_board[j+dieVal] == -1 )
            {
              r.back().m_board[j+dieVal]++;
              r.back().m_board[25]--;
            }
            
            //Place our checker on the new spot
            r.back().m_board[j+dieVal]++;
          }
          
          else
          {
            r.back().m_score++;
          }

          //Record the move. If j+dieVal > 24, it means we bear off with this move
          r.back().m_move.push_back(j);
          r.back().m_move.push_back(j+dieVal);

          //If we pushed j forward, move it back
          if ( j_edit == true )
          {
            j-=( advance - (25-dieVal) );
            j_edit = false;
          }          
        }
      }
      
      //And at this point, if we didn't execute X or O generation, it means 
      //no one owned the spot or no one could move from a spot if it was owned
    } 
    
    cout << "\n  r.size() = " << r.size() << endl;
  } 
  
  return;
}                                        

//Checks to see if all dice in a state have been used. Returns true if not.
bool AI::continue_generation( const backgammon_state& state )
{
  for ( int i = 0; i < state.m_dice_used.size(); i++ )
    if ( state.m_dice_used[i] == false )
      return true;
      
  return false;
}

//Checks to see if a state is able to bear pieces off.
void AI::bear_check( backgammon_state& state )
{
  state.m_bear_off = false;
  
  int sum = 0;
  
  if ( state.m_player == 0 ) 
  {
    sum += state.m_score;
    
    //Player X's home board are points 1-6.
    for ( int i = 1; i < 7; i++ )
      if ( state.m_board[i] < 0 )
        sum += (state.m_board[i]*-1);  
  }
 
  else
  {
    sum+=state.m_score;
    
    //Player O's home board are points 19-24.
    for ( int i = 19; i < 25; i++ )
      if ( state.m_board[i] > 0 )
        sum += state.m_board[i];
  }
  
  //Sum  = number of pieces in the home board + the score
  if ( sum == 15 )
    state.m_bear_off = true;
  
  return;
}

//Finds the spot in the home zone furthest away from the edge of the board
//and within the range of the die from the edge of the board
// 0 0 0 2 6 3->exit, using a 5
int AI::advance_to( const backgammon_state& state, int dieVal )
{
  cout << "adv>";
  //player x
  if (state.m_player == 0 )
  {
    for ( int i = dieVal; i > 0; i-- )
    {
      if ( state.m_board[i] < 0 )
      { 
        cout << i << " ";
        return i;
      }
    }
  }
  
  //player O
  else
  {
    for ( int i = (25-dieVal); i < 25; i++ )
    {
      if ( state.m_board[i] > 0 )
        return i;
    }
  }
  
  return dieVal;
}

//checks backward a few positions to dieVal from the current point to see
//if we could have borne off from further back, and if so returns true
//prevents things like:
// 0 2 0 4 0 0, dieval = 5
//thinking it can bear off from 3
bool AI::check_back( const backgammon_state& state, int curr_pos, int dieVal )
{
  //player x
  if ( state.m_player == 0 )
  {
    for ( int i = (curr_pos+1); i <= dieVal; i++ )
    //for ( int i  = (curr_pos+1); i < 7; i++ )
    {
      if (state.m_board[i] < 0)
        return true;
    }
  }
  
  //player o
  else
  {
    for ( int i = (curr_pos-1); i >= (25-dieVal); i-- )
    //for ( int i = (curr_pos-1); i >18; i-- )
    {
      if ( state.m_board[i] > 0 )
        return true;
    }
  }
  
  return false; 
}

//Perform a move contained in a state
void AI::make_move( const backgammon_state& state )
{
  for ( int j = 0; j < state.m_move.size(); j+=2 )
  {
    //If the move is trying to bear off
    if ( ((state.m_player == 1) && (state.m_move[j+1] > 24 ))
      || ((state.m_player == 0) && (state.m_move[j+1] < 1 )) )
    {
      cout << "\n>>BEARING OFF FROM " << state.m_move[j] << endl;
      serverBoards[0].bearOff( state.m_move[j] );
    }
    
    //If the move is not trying to bear off
    else
    {
      cout << "\n>>MOVING FROM " << state.m_move[j] << " TO " << state.m_move[j+1] << endl;
      serverBoards[0].move( state.m_move[j], state.m_move[j+1] );
    }
    
    cin.get();
  }
  
  return;
}

/**************************** end generation moves ***************************/

/*************************** choosing the best move **************************/
backgammon_state AI::QSHTABIDM( const backgammon_state& s,
                                unsigned int d,
                                unsigned int qsd,
                                double alpha,
                                double beta
                              )
{
  cout << "QSHTABIDM( s, " << d << ", " << qsd << ", " << alpha << ", " << beta << ")" << endl;
  s.print();
  
  if ( d == 0 || terminal_test(s) )
  {
    cout << "  RETURNING STATE EVAL " << h_state_eval(s) << endl;
    return s;
  }
    
  //Reset the move and prune counters
  _MOVES = 0;
  _PRUNES = 0;

  //Create the frontier
  deque<backgammon_state> frontier;
  
  //Populate the frontier
  gen_moves( s, frontier );
  
  //If we couldn't make a move from this state, just return this state with 
  //no moves and cry ourselves to sleep
  if ( frontier.empty() )
  {
    //CHECK THIS, DOES IT MAKE SENSE?
    _ALL_STOP = true;
    return s;
  }
  
  //The value returned from chance (fxnal eval of current frontier item)
  double curr_val = 0;

  //The move associated the best curr_val
  backgammon_state best_action = frontier[0];

  cout << "QSHTABIDM INITIAL MOVES GENERATED" << endl;
  
  //For each move in the frontier
  for ( int i = 0; i < frontier.size(); i++ )
  {
    if ( TLR( frontier[i] ) )
    {
      _ALL_STOP = true;
      return best_action;
      //make_move( best_action );
    }
    
    curr_val = Chance_s1( frontier[i], d-1, qsd, alpha, beta, 0 );
    cout << "    curr_val = " << curr_val << endl;
    //Fail high for max
    if ( curr_val >= beta )
    {
      //prune
      cout << "pruning..." << endl;
      _PRUNES++;
      break;
    }
    
    //We're in the (alpha,beta) window
    //else if ( (curr_val > alpha) && (curr_val < beta) ) 
    else if ( curr_val > alpha )
    {
      //Update alpha
      alpha = curr_val;
      
      //Update best move
      best_action = frontier[i];
    }
    
    //If <= alpha, we don't do anything.
  }
  
  cout << "    INITIAL STATE: " << endl;
  s.print();
  
  cout << "    RETURNING BEST ACTION: " << endl;
  best_action.print();
  _ALL_STOP = true;
  return best_action;
}

double AI::Chance_s1( const backgammon_state& s,
                      unsigned int d,
                      unsigned int qsd,
                      double alpha,
                      double beta,
                      //int player //max calling? -> 0, otherwise any value
                      bool player
                    )
{  
  //If we've geen given a terminal state, just throw back with a huge value
  //saying this is a good place to go.
  if ( terminal_test(s) )
    return h_state_eval(s);
  
  //Copy the current state so we can do die combination generation for it
  backgammon_state gen_for;
  gen_for = s;

  //Resize the dice so we can put all combinations into it
  gen_for.m_dice.resize(2);
  
  //Number of succeeding states from s is always 21 here
  //One for each die pairing. 1,1 1,2...6,6
  int N = 21;
  
  //Variables for alg use
  double value = 0;   //Value of the call returned from max or min
  double AX = 0;      //Resizing lower bound
  double BX = 0;      //Resizing upper bound
  
  //Initialize A, B, vsum
  double A = N*(alpha - _Upper) + _Upper; //Our shifting alpha
  double B = N*(beta  - _Lower) + _Lower; //Our shifting beta
  double val_sum = 0;
  
  //For each combination of dice rolls possible from this state: 1,1 1,2 .. 6,6
  for ( int i = 1; i < 7; i++ )
  {
    for ( int j = 1; j < 7; j++ )
    {
      //Update AX and BX
      AX = max( A, _Lower );
      BX = max( B, _Upper );
      
      //Force gen_for to have every possible dice combination so we can average
      //their expected values
      if ( i != j )
      {
        gen_for.m_dice.resize(2);
        gen_for.m_dice[0] = i;
        gen_for.m_dice[1] = j;
      }
      
      else
      {
        gen_for.m_dice.resize(4);
        gen_for.m_dice[0] = i;
        gen_for.m_dice[1] = i;
        gen_for.m_dice[2] = i;
        gen_for.m_dice[3] = i;
      }
              //Max called?       Have min called                       Have max called
      //value = ( player == 0 ) ? ( MinV( gen_for, d, qsd, AX, BX ) ) : ( MaxV( gen_for, d, qsd, AX, BX ) );
      value = MiniMaxV( gen_for, d, qsd, AX, BX, player );
      
      //Check for pruning abilities
      if ( value <= A )
      {
        _PRUNES++;
        //return (alpha - _MyEpsilon);
        return alpha;
      }
      
      if ( value >= B )
      {
        _PRUNES++;
        //return (beta + _MyEpsilon);
        return beta;
      }
      
      //Update the sums and such
      val_sum += value;
      
      A += (i != j) ? (1.0/18.0*( _Upper - value )) : (1.0/36.0*( _Upper - value ));
      B += (i != j) ? (1.0/18.0*( _Lower - value )) : (1.0/36.0*( _Lower - value ));
    }
  }
  
  return (val_sum / N);
}          

double AI::MiniMaxV( const backgammon_state& s, 
                 unsigned int d,
                 unsigned int qsd,
                 double alpha,
                 double beta,
                 bool player //max called? true , min called? false
               )
{ 
  if ( player == 0 )
    cout << "MinV";
  else
    cout << "MaxV";
   
  cout << "( s, " << d << ", " << qsd << ", " << alpha << ", " << beta << ")" << endl;
  //s.print();
  
  if ( d == 0 || terminal_test(s) )
  {
    cout << "   RETURNING STATE EVAL " << h_state_eval(s) << endl;
    return h_state_eval(s);
  }
  
  //Create the frontier
  deque<backgammon_state> frontier;

  //Populate the frontier
  gen_moves( s, frontier );
  
  //The value returned from chance (fxnal eval of current frontier item)
  double curr_val = 0;
  
  //For storing the best value returned from chance so far
  double best_val = _nInf;

  //If we couldn't make a move from this state, since state_eval will say
  //not to come to this state
  if ( frontier.empty() )
  {
    //THIS NEEDS TO BE CHECKED OUT. DOES THIS MAKE SENSE?
    cout << "   RETURNING STATE EVAL (NM!) " << h_state_eval(s) << endl;
    return h_state_eval(s);
  }
  
  //Set our best action to the first possible action
  backgammon_state best_action = s;
  deque<int> best_move = frontier[0].m_move;
  
  //Toggle player for the next layer of calls
  player = !player;
  
  cout << "INITIAL MOVES GENERATED" << endl;
  
  //For each move in the frontier
  for ( int i = 0; i < frontier.size(); i++ )
  {  
    if ( TLR( frontier[i] ) )
    {
      best_action.m_move = best_move;
      return h_state_eval( best_action );
    }
    
    curr_val = Chance_s1( frontier[i], d-1, qsd, alpha, beta, player );
    cout << "    curr_val = " << curr_val << endl;
    
    //Update the best value
    if ( curr_val > best_val )
    {
      cout << "      updating best_val..." << endl;
      best_val = curr_val;
      best_move = frontier[i].m_move;
    }
    
    //If min 
    if ( player == false )
    {
      //fail low
      if ( curr_val <= alpha )
      {
        //prune
        cout << "pruning..." << endl;
        _PRUNES++;
        break;
      }
      
      //no fail
      else if ( curr_val < beta )
      {
        beta = curr_val;
      }
      
      //if >= beta, fail high for min, don't do anything
    }
    
    //If max
    else
    {
      //fail high
      if ( curr_val >= beta )
      {
        //prune
        cout << "pruning..." << endl;
        _PRUNES++;
        break;
      }
      
      //no fail
      else if ( curr_val > alpha )
      {
        alpha = curr_val;
      }
      
      //if <= alpha, fail low for max, don't do anything
    }
  }
  
  cout << "   RETURNING BEST VALUE: " << best_val << endl;
  return best_val;
}

/*****************************************************************************/
/***************************** misc functions ********************************/
/*****************************************************************************/

bool AI::terminal_test( const backgammon_state& s )
{
  if ( (player0Score() == 15) || (player1Score() == 15) )
  {
    //cout << "    TERMINAL CASE CONFIRMED" << endl;
    return true;
  }

  return false;
}
     
//Returns whether or not we have time to perform the move
bool AI::TLR( const backgammon_state& s )
{
  _now = clock();
  
  //cout << "    TIME ELAPSED: " << (_now - _start) / CLOCKS_PER_SEC * 1000 << endl;
  cout << "    TIME ELAPSED: " << (_now - _start) << endl;
  
  //if ( (((_now - _start) / CLOCKS_PER_SEC * 1000 ) + h_time_cost(s)) > _time_allot )
  if ( ((_now - _start) + h_time_cost(s)) > _time_allot )
  {
    cout << "    TIME LIMIT REACHED!" << endl;
    return true;
  }
  
  return false;
}

//Sets the amount of time we're going to allot to generating a move for this 
//turn. 
void AI::set_time( const backgammon_state& s )
{
  _time_allot = 0;
  
  //For our first 8 moves of the game spend .3% of our total time on this move
  //Early game isn't too hard
  if ( turnNumber() <= 16 ) 
    _time_allot += ( s.m_player == 0 ) ? ( player0Time()*.003 ) : ( player1Time()*.003 );
  
  //For moves 9-80, spend .5% of our time on the move
  //Mid-game is a bit harder, so we spend quite a bit of time per move
  else if ( turnNumber() <= 160 )
    _time_allot += max(( s.m_player == 0 ) ? ( player0Time()*.005 ) : ( player1Time()*.005 ), 3.4);
  
  //For moves 81-150, spend 1% of our time on the move
  //Late game should be a little easier too, especially this late
  else if ( turnNumber() <= 300 )
    _time_allot += max(( s.m_player == 0 ) ? ( player0Time()*.01 ) : ( player1Time()*.01 ), 2.8);
  
  else
    _time_allot += _time_allot += max(( s.m_player == 0 ) ? ( player0Time()*.1 ) : ( player1Time()*.1 ), 1.0);
  
  //And now, since player0Time() and player1Time() return number of seconds,
  //Turn it into milliseconds to work with our other funcions
  _time_allot*=1000;
  
  cout << "_time_allot = " << _time_allot << endl;
  
  return;
} 
/*****************************************************************************/
/********************************** heuristics *******************************/
/*****************************************************************************/

double AI::h_state_eval( const backgammon_state& s )
{
  double score = 0;
  //cout << "  state eval called" << endl;
  
  for ( int j = 0; j < 26; j++ )
  {
    //O (p1) bar point
    if ( j == 0 )
    {
      //O owns the point and we are O, gotta get out of here D:
      if ( (s.m_board[j] > 0) && (s.m_player == 1) )
      { 
        //-2.0x for making the point
        //-1.5x for blotting the point
        ( s.m_board[j] > 1 ) ? ( score -= 2.0*25 ) : ( score -= 1.5*25 );
      }
      
      //O owns the spot and we are X, keep O backed up >:)
      else if ( (s.m_board[j] > 0) && (s.m_player == 1) )
      {
        //+2.5x for O making the point
        //+1.75x for O blotting the point
        ( s.m_board[j] > 1 ) ? ( score += 2.5*25 ) : ( score += 1.75*25 );
      }
    }
    
    //O (p1) start quadrant (where he drops pieces off the bar)
    else if ( j >= 1 && j <= 6 )
    {
      //O owns the point and we are O, gotta start somewhere :|
      if ( (s.m_board[j] > 0) && (s.m_player == 1) )
      { 
        //+1.5x for making the point
        //-1.0x for blotting the point
        ( s.m_board[j] > 1 ) ? ( score += 1.5*j ) : ( score -= j );
      }
      
      //X owns the spot and we are X, getting close to home :D
      else if ( (s.m_board[j] < 0) && (s.m_player == 0) )
      {
        //+2.5x for making the point
        //+1.75x for blotting the point
        ( s.m_board[j] < -1 ) ? ( score += 2.5*(25-j) ) : ( score += 1.75*(25-j) );
      }
    }
    
    //Open warfare, anyone's field
    else if ( j >= 7 && j <= 18 )
    {
      //O owns the point and we are O, working on it :)
      if ( (s.m_board[j] > 0) && (s.m_player == 1) )
      { 
        //+1.5x for making the point
        //+0.5x for blotting the point
        ( s.m_board[j] > 1 ) ? ( score += 1.5*j ) : ( score += 0.5*j );
      }
      
      //X owns the spot and we are X, working on it :)
      else if ( (s.m_board[j] < 0) && (s.m_player == 0) )
      {
        //+1.5x for making the point
        //+0.5x for blotting the point
        ( s.m_board[j] < -1 ) ? ( score += 1.5*(25-j) ) : ( score += 0.5*(25-j) );
      }
    }
    
    //X (p0) start quadrant (where he drops pieces off the bar)
    else if ( j >= 19 && j <= 24 )
    {
      //O owns the point and we are O, getting close to home :D
      if ( (s.m_board[j] > 0) && (s.m_player == 1) )
      { 
        //+2.5x for making the point
        //+1.75x for blotting the point
        ( s.m_board[j] > 1 ) ? ( score += 2.5*j ) : ( score += 1.75*j );
      }
      
      //X owns the spot and we are X, gotta start somewhere :|
      else if ( (s.m_board[j] < 0) && (s.m_player == 0) )
      {
        //+1.5x for making the point
        //-1.0x for blotting the point
        ( s.m_board[j] < -1 ) ? ( score += 1.5*(25-j) ) : ( score -= (25-j) );
      }
    }
    
    //X (p0) bar point
    if ( j == 0 )
    {
      //X owns the point and we are O, keep X backed up >:)
      if ( (s.m_board[j] < 0) && (s.m_player == 1) )
      { 
        //+2.5x for O making the point
        //+1.75x for O blotting the point
        ( s.m_board[j] < -1 ) ? ( score += 2.5*25 ) : ( score += 1.75*25 );
      }
      
      //X owns the spot and we are X, gotta get out of here D:
      else if ( (s.m_board[j] > 0) && (s.m_player == 1) )
      {
        //-2.0x for making the point
        //-1.5x for blotting the point
        ( s.m_board[j] < -1 ) ? ( score -= 2.0*25 ) : ( score -= 1.5*25 );
      }
    }
  }
  
  //cout << "  state eval complete" << endl;
  
  return score;
}

//Returns the number of milliseconds expected to elapse between function calls
double AI::h_time_cost( const backgammon_state& s )
{
  double estimate = 0;
  
  for ( int i = 0; i < 26; i++ )
  {
    //For each spot on the board that a player owns, add one
    if ( s.m_player == 0 && s.m_board[i] < 0 )
      estimate++;
    
    else if ( s.m_player == 1 && s.m_board[i] > 0 )
      estimate++;
  }
   
  //Each move counted above can possibly be made using either die, and then
  //the other die. So x4.  
  
  //Since each possible move counted earlier could possibly generate 21
  //successors in the chance nodes before the next check happens,
  //multiply this number by 21.
  
  //The move generator seems to generate a full move state in about .05ms
  //So that's 20 moves / 1 ms, which nigh negates the x21 from the chance node.
  
  //Then if we rolled doubles, we're going to generate a lot more states
  //than we would with singles, so we'll multiply by 4.0
  estimate*=(2.0 * ( (s.m_dice.size() == 2) ? ( 1.0 ) : ( 4.0 ) ));
  cout << "    TIMECOST ESTIMATE: " << estimate << endl;
  return estimate;
}

/*****************************************************************************/
/****************************** provided functions ***************************/
/*****************************************************************************/
const char* AI::username()
{
  return "Shell AI";
  //return "Efsie";
}

const char* AI::password()
{
  return "password";
}

//Prints the board to the screen
void AI::displayBoard()
{
  cout << "Dice : ";
  
  for ( int i = 0; i < 4; i++ )
  {
    cout << getDie(i);
    if (i < 3)
      cout << ",";
  }
  
  cout << endl;
  
  if ( getPlayerID() == 0 )
    cout << "You are X." << endl;
  
  else
    cout << "You are O." << endl;
  
  cout << "Scores    X: " << player0Score() << "   O: " << player1Score();
  cout << endl;
  cout << "Times     X: " << player0Time() <<  "   O: " << player1Time();
  cout << endl;
  cout << "   +24-23-22-21-20-19--25--18-17-16-15-14-13-+" << endl;
  
  for ( int row = 1; row < 6; row++ )
  {
    cout << "   ";
    cout << "|";
    
    for (int col = 24; col > 18; col --)
      displayStack(col, row);
    
    cout << "|";
    displayStack(25, row);
    cout << "|";
    
    for (int col = 18; col > 12; col--)
      displayStack(col, row);
    
    cout << "|" << endl;
  }
  
  cout << "   |                  |BAR|                  |" << endl;
  
  for (int row = 5; row > 0; row --)
  {
    cout << "   ";
    cout << "|";
    
    for (int col = 1; col < 7; col ++)
      displayStack(col, row);
    
    cout << "|";
    displayStack(0, row);
    cout << "|";
    
    for (int col = 7; col < 13; col++)
      displayStack(col, row);
    
    cout << "|" << endl;
  }
  
  cout << "   +1--2--3--4--5--6---0---7--8--9--10-11-12-+" << endl;
  
  return;
}

//Writes 3 characters of the ASCII GUI to the screen
void AI::displayStack( int point, int height )
{
  int checkers = getPoint(point);
  char player = 'O';
  
  if ( checkers < 0 )
  {
    checkers *= -1;
    player = 'X';
  }
  
  if ( checkers < height )
    cout << "  ";
  
  else if ( height < 5 )
    cout << player << " ";
  
  else if ( checkers < 10 )
    cout << checkers << " ";
  
  else
    cout << checkers;
  
  cout << " ";
  
  return;
}

//Gets the value of the die specified
int AI::getDie( int i )
{
  switch ( i )
  {
    case 0:
      return serverBoards[0].die1();
    case 1:
      return serverBoards[0].die2();
    case 2:
      return serverBoards[0].die3();
    case 3:
      return serverBoards[0].die4();
    default:
      cout << "ERROR: getDie expects an index 0 to 3." << endl;
      return 0;
  }
}

//Gets the value of the point specified
int AI::getPoint( int i )
{
  switch ( i )
  {
    case 0:
      return serverBoards[0].bar0();
    case 1:
      return serverBoards[0].point1();
    case 2:
      return serverBoards[0].point2();
    case 3:
      return serverBoards[0].point3();
    case 4:
      return serverBoards[0].point4();
    case 5:
      return serverBoards[0].point5();
    case 6:
      return serverBoards[0].point6();
    case 7:
      return serverBoards[0].point7();
    case 8:
      return serverBoards[0].point8();
    case 9:
      return serverBoards[0].point9();
    case 10:
      return serverBoards[0].point10();
    case 11:
      return serverBoards[0].point11();
    case 12:
      return serverBoards[0].point12();
    case 13:
      return serverBoards[0].point13();
    case 14:
      return serverBoards[0].point14();
    case 15:
      return serverBoards[0].point15();
    case 16:
      return serverBoards[0].point16();
    case 17:
      return serverBoards[0].point17();
    case 18:
      return serverBoards[0].point18();
    case 19:
      return serverBoards[0].point19();
    case 20:
      return serverBoards[0].point20();
    case 21:
      return serverBoards[0].point21();
    case 22:
      return serverBoards[0].point22();
    case 23:
      return serverBoards[0].point23();
    case 24:
      return serverBoards[0].point24();
    case 25:
      return serverBoards[0].bar25();
    default:
      cout << "ERROR: getPoint requires an index 0 to 25." << endl;
      return 0;
  }
}

//The default run() function included
/*
bool AI::run()
{
  //Default code provided by professor to manually play.
  int action, from, to;
  displayBoard();
  cout << "Select an action:" << endl
    << "  1. Move" << endl
    << "  2. Bear Off" << endl
    << "  3. End turn" << endl;
  cin >> action;
  switch (action)
  {
    case 1:
    cout << "Move piece from where?" << endl;
    cin >> from;
    cout << "Move piece to where?" << endl;
    cin >> to;
    serverBoards[0].move(from, to);
    break;
    case 2:
    cout << "Bear off from where?" << endl;
    cin >> from;
    serverBoards[0].bearOff(from);
    break;
    case 3:
    cout << "Ending your turn" << endl;
    break;
  }
  //Returning true ends your turn, returning false requests a status update
  //and starts over at run.
  return action==3;
}*/

/*****************************************************************************/
/************************* outdate functions *********************************/
/*****************************************************************************/
/*double AI::MaxV( const backgammon_state& s, 
                 unsigned int d,
                 unsigned int qsd,
                 double alpha,
                 double beta
               )
{
  cout << "MaxV( s, " << d << ", " << qsd << ", " << alpha << ", " << beta << ")" << endl;
  //s.print();
  
  if ( d == 0 || terminal_test(s) )
  {
    cout << "  RETURNING STATE EVAL " << h_state_eval(s) << endl;
    return h_state_eval(s);
  }
  
  //Create the frontier
  deque<backgammon_state> frontier;

  //Populate the frontier
  gen_moves( s, frontier );
  
  //The value returned from chance (fxnal eval of current frontier item)
  double curr_val = 0;
  
  //For storing the best value returned from chance so far
  double best_val = _nInf;

  //If we couldn't make a move from this state, just return this state with 
  //no moves and cry ourselves to sleep
  if ( frontier.empty() )
  {
    //THIS NEEDS TO BE CHECKED OUT. DOES THIS MAKE SENSE?
    cout << "   RETURNING STATE EVAL (NMV!) " << h_state_eval(s) << endl;
    return h_state_eval(s);
  }
  
  backgammon_state best_action = frontier[0];
  
  
  cout << "MaxV INITIAL MOVES GENERATED" << endl;
  
  //For each move in the frontier
  for ( int i = 0; i < frontier.size(); i++ )
  {
    if ( TLR( frontier[i] ) )
    {
      return h_state_eval( best_action );
      //make_move( best_action );
    }
  
    curr_val = Chance_s1( frontier[i], d-1, qsd, alpha, beta, 0 );
    cout << "    curr_val = " << curr_val << endl;
    
    //Update the best value
    if ( curr_val > best_val )
    {
      cout << "      updating best_val..." << endl;
      best_val = curr_val;
      best_action = frontier[i];
    }
    
    //Fail high for max
    if ( curr_val >= beta )
    {
      //prune
      cout << "pruning..." << endl;
      _PRUNES++;
      break;
    }
    
    //We're in the (alpha,beta) window
    else if ( (curr_val > alpha) && (curr_val < beta) ) //&& curr_val < beta <--inherent; didn't go into the previous if
    {
      //Update alpha
      alpha = curr_val;
    }
    
    //If we're <= alpha, we don't do anything (fail low for max)
  }
  
  cout << "    RETURNING BEST VALUE: " << best_val << endl;
  return best_val;
}*/

/*double AI::MinV( const backgammon_state& s, 
                 unsigned int d,
                 unsigned int qsd,
                 double alpha,
                 double beta
               )
{ 
  cout << "MinV( s, " << d << ", " << qsd << ", " << alpha << ", " << beta << ")" << endl;
  //s.print();
  
  if ( d == 0 || terminal_test(s) )
  {
    cout << "   RETURNING STATE EVAL " << h_state_eval(s) << endl;
    return h_state_eval(s);
  }
  
  //Create the frontier
  deque<backgammon_state> frontier;

  //Populate the frontier
  gen_moves( s, frontier );
  
  //The value returned from chance (fxnal eval of current frontier item)
  double curr_val = 0;
  
  //For storing the best value returned from chance so far
  double best_val = _nInf;

  //If we couldn't make a move from this state, just return this state with 
  //no moves and cry ourselves to sleep
  if ( frontier.empty() )
  {
    //THIS NEEDS TO BE CHECKED OUT. DOES THIS MAKE SENSE?
    cout << "   RETURNING STATE EVAL (NMV!) " << h_state_eval(s) << endl;
    return h_state_eval(s);
  }
  
  backgammon_state best_action = frontier[0];
  
  cout << "MinV INITIAL MOVES GENERATED" << endl;
  
  //For each move in the frontier
  for ( int i = 0; i < frontier.size(); i++ )
  {  
    if ( TLR( frontier[i] ) )
    {
      return h_state_eval( best_action );
      //make_move( best_action );
    }
  
    curr_val = Chance_s1( frontier[i], d-1, qsd, alpha, beta, 1 );
    cout << "    curr_val = " << curr_val << endl;
    //Update the best value
    if ( curr_val > best_val )
    {
      cout << "      updating best_val..." << endl;
      best_val = curr_val;
      best_action = frontier[i];
    }
    
    //Fail low for min
    if ( curr_val <= alpha )
    {
      //prune
      cout << "pruning..." << endl;
      _PRUNES++;
      break;
    }
    
    //We're in the (alpha,beta) window
    else if ( curr_val < beta ) //&& curr_val > alpha <--inherent; didn't go into the previous if
    {
      //Update beta
      beta = curr_val;
    }
    
    //If we're >= beta, we don't do anything (fail high for min)
  }
  
  cout << "   RETURNING BEST VALUE: " << best_val << endl;
  return best_val;
}*/

/*double AI::Chance( const backgammon_state& s, 
                   unsigned int d,
                   unsigned int qsd,
                   double alpha,
                   double beta,
                   int player //max calling? -> 0, otherwise any value
                 )
{  
  cout << "Chance( s, " << d << ", " << qsd << ", " << alpha << ", " << beta << ")" << endl;

  double sum = 0;
  backgammon_state gen_for = s;
  
  for ( int i = 1; i < 7; i++ )
  {
    for ( int j = 1; j < 7; j++ )
    {
      cout << "  making state << " << i << ", " << j << endl;
      //Set up the moves for the subsequent states
      if ( i != j )
      {
        gen_for.m_dice[0] = i;
        gen_for.m_dice[1] = j;
      }
      
      else
      {
        for ( int q = 0; q < 4; q++ )
          gen_for.m_dice[q] = j;
      }
      
      //If max called 
      if ( player == 0 )
      {
        sum += (i == j) ? ((1.0/36.0)*MinV( gen_for, d, qsd, alpha, beta )) : ((1.0/18.0)*MinV( gen_for, d, qsd, alpha, beta ));
      }
      
      //If min player called
      else
      {
        sum += (i == j) ? ((1.0/36.0)*MaxV( gen_for, d, qsd, alpha, beta )) : ((1.0/18.0)*MaxV( gen_for, d, qsd, alpha, beta ));
      }
    }
  }

  cout << "  RETURNING SUM " << sum << endl;
  return sum;
}*/

// END OF FILE ----------------------------------------------------------------