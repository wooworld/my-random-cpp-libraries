/*
  @file main.nxc
  @auth Gary Steelman
  @desc The main driver for a robot built using the Lego Mindstorm NXT 2.0 kit.
  @edit 09 Apr 2011
*/

#include "NXCDefs.h"           // Unnecessary, included for clarity
#include "_3DFrame.h"          // The Frames used to track points of interest
#include "numeric_constants.h" // Useful numeric constants

#define SMALL_GEAR_TEETH  12
#define LARGE_GEAR_TEETH  36

#define GEAR_RATIO        (LARGE_GEAR_TEETH / SMALL_GEAR_TEETH)
#define DEG_PER_STEP      _DEG_PER_CIRCLE * GEAR_RATIO

#define BOT_WIDTH         17
#define BOT_LEG_LEN       10
#define REV_CIRC_DIST     (2.0 * _PI * BOT_WIDTH)

#define ACC_ROT_ERR       7.5
#define ROT_ERR_SPD       10

#define MIN_ROT           0.5

#define MOT_LEFT          OUT_B
#define MOT_RIGHT         OUT_A
#define MOT_ALL           OUT_AB

// Comment out this line to indicate the robot is walking on a non-frictionless surface
//#define FRICTIONLESS      1

#ifdef FRICTIONLESS
  #define SLIP_FIX        1.5
  #define CM_PER_STEP     (((44.5 + 40.5 + 42.0 + 43.2 + 43.0 + 40.1) / 6.0) / 5.0)
  #define DEG_PER_ROT     DEG_PER_STEP * ((REV_CIRC_DIST / CM_PER_STEP) + SLIP_FIX)
  #define BOT_MAX_SPD     70
  #define BOT_MAX_ACC     15
#else
  #define CM_PER_STEP     (((31.0 + 35.2 + 33.7 + 33.9 + 36.3 + 32.0) / 6.0) / 5.0)
  #define DEG_PER_ROT     DEG_PER_STEP * (REV_CIRC_DIST / CM_PER_STEP)
  #define BOT_MAX_SPD     100
  #define BOT_MAX_ACC     25
#endif

#define BOT_WALK_SPD BOT_MAX_SPD
#define BOT_ROT_SPD  BOT_MAX_SPD

safecall void InitMotors();

safecall void Step  ( float steps, char speed );
safecall void RStep ( float steps, char speed );

safecall void Rotate( float degrees, char speed );

safecall void Move  ( float F[], float& G[] );
safecall void RMove ( float F[], float& G[] );

float ORIGIN[12];
float currLoc[12];
float nextLoc[12];
float tempLoc[12];

/*
  @task main
  @desc The main task for the robot. Over-arching control flow.
  @pre  None.
  @post Performs the controlling logic for the robot.
*/
task main()
{
  /*unsigned int start_time = 0;
  float    total_time     = 0;
  
  float F[12];
  float G[12];
  float H[12];
  _3D_Init( F );
  G = F;
  H = F;*/

  _3D_Init( ORIGIN );
  _3D_Init( currLoc );
  _3D_Init( nextLoc );
  _3D_Init( tempLoc );
  
  InitMotors();
  
  // Z is forward, X is left, Y is up
  _3D_translate_rel( currLoc, -10.0, 0.0, -10.0, nextLoc );
  Move( currLoc, nextLoc );
  currLoc = nextLoc;
  
  /*_3D_translate_rel( ORIGIN, -10.0, 0.0, 0.0, nextLoc );
  _3D_move( currLoc, nextLoc );
  Wait( SEC_5 );
  Move( currLoc, nextLoc );
  Wait( SEC_5 );
  _3D_move( currLoc, nextLoc );
  Wait( SEC_5);
  currLoc = nextLoc;*/
  
  nextLoc = ORIGIN;
  Move( currLoc, nextLoc );
  _3D_move( currLoc, nextLoc );
  currLoc = nextLoc;
  
  while ( true )
  {
    Wait( SEC_5 );
  }
}

// Walk forward
// Use a lower speed for more accurate movement results
safecall void Step( float steps, char speed )
{
  printf( "Stepping!", 4 );
  
  float angle_target;
  float MOT_RIGHT_FIX;
  float MOT_LEFT_FIX;
  
  angle_target = DEG_PER_STEP * steps;
  
  RotateMotorEx( MOT_ALL, speed, angle_target, 0, TRUE, FALSE );
  Off( MOT_ALL );
  
  /*
    Calculate and apply small angle fixes to better align the motors after the
    initial rotation stops. Iterates until both motors have been aligned to
    within ACC_ROT_ERR degrees of the intended degrees of rotation
  */
  MOT_RIGHT_FIX = angle_target - MotorRotationCount( MOT_RIGHT );
  MOT_LEFT_FIX  = angle_target - MotorRotationCount( MOT_LEFT );
  
  while ( abs( MOT_RIGHT_FIX ) > ACC_ROT_ERR || abs( MOT_LEFT_FIX ) > ACC_ROT_ERR )
  {
    //printf( "Stepfix L: %f, R: %f", MOT_LEFT_FIX, MOT_RIGHT_FIX );
    NumOut( 0, LCD_LINE7, MOT_LEFT_FIX );
    NumOut( 0, LCD_LINE8, MOT_RIGHT_FIX );
    RotateMotor( MOT_RIGHT, ROT_ERR_SPD, MOT_RIGHT_FIX );
    Off( MOT_RIGHT );

    RotateMotor( MOT_LEFT, ROT_ERR_SPD, MOT_LEFT_FIX );
    Off( MOT_LEFT );
    
    // VM Clocks once per MS, need to do this to allow the values read to be
    // the correctly output values from the previous tick
    Wait( MS_1 );
    
    MOT_RIGHT_FIX = angle_target - MotorRotationCount( MOT_RIGHT );
    MOT_LEFT_FIX  = angle_target - MotorRotationCount( MOT_LEFT );
  }
  
  // Rotation count resets can take up to 1 MS to apply, allot time for it
  ResetRotationCount( MOT_ALL );
  Wait( MS_1 );
}

// Walk backward
safecall void RStep( float steps, char speed )
{
  printf( "RStepping!", 4 );
}

safecall void Rotate( float degrees, char speed )
{
  printf( "Rotating!", 4 );
  
  float angle_target;
  float MOT_RIGHT_FIX;
  float MOT_LEFT_FIX;

  angle_target = DEG_PER_ROT * degrees / _DEG_PER_CIRCLE;

  if ( abs(angle_target) < MIN_ROT )
  {
    return;
  }
  
  // Rotate right by holding right at stop and forward left
  // Could just as easily do this by holding left at stop and backward right
  else if ( angle_target < 0.0 )
  {
    // angle_target was <0, symbolizing a right-rotation, but the value must
    // be positive to make the left motor move forward
    angle_target = -angle_target;
    
    RotateMotor( MOT_LEFT, speed, angle_target );
    Off( MOT_LEFT );
    
    MOT_LEFT_FIX = angle_target - MotorRotationCount( MOT_LEFT );
    
    while ( abs( MOT_LEFT_FIX ) > ACC_ROT_ERR )
    {
      printf( "Rotfix L: %f", MOT_LEFT_FIX );
      RotateMotor( MOT_LEFT, ROT_ERR_SPD, MOT_LEFT_FIX );
      Off( MOT_LEFT );

      Wait( MS_1 );

      MOT_LEFT_FIX = angle_target - MotorRotationCount( MOT_LEFT );
    }
  }
  
  // Rotate left by holding left at stop and forward right
  // Could just as easily do this by holding right at stop and backward left
  else
  {
    RotateMotor( MOT_RIGHT, speed, angle_target );
    Off( MOT_RIGHT );

    MOT_RIGHT_FIX  = angle_target - MotorRotationCount( MOT_RIGHT );

    while ( abs( MOT_RIGHT_FIX ) > ACC_ROT_ERR )
    {
      printf( "Rotfix R: %f", MOT_RIGHT_FIX );
      RotateMotor( MOT_RIGHT, ROT_ERR_SPD, MOT_RIGHT_FIX );
      Off( MOT_RIGHT );

      Wait( MS_1 );

      MOT_RIGHT_FIX  = angle_target - MotorRotationCount( MOT_RIGHT );
    }
  }

  // DO NOT RESET MOTOR ROTATION COUNTS, NECESSARY FOR PATH CORRECTION LATER
  /* resetting for now because implementation of path correction is coming later */
  ResetRotationCount( MOT_ALL );
  Wait( MS_1 );
}

void InitMotors()
{
  // Set the interval the motors are timed at
  SetMotorRegulationTime( MS_1 );
  
  // Don't limit intermediary results
  SetMotorRegulationOptions( OUT_REGOPTION_NO_SATURATION );
  
  // Max speed for motors is 100 (max) and max acceleration is 25
  PosRegSetMax( MOT_ALL , BOT_MAX_SPD, BOT_MAX_ACC );
}

// Move from one reference frame to another
void Move( float F[], float& G[] )
{
  float F2  = F[2];
  float F3  = F[3];
  float F10 = F[10];
  float F11 = F[11];
  //float G2  = G[2];
  float G3  = G[3];
  //float G10 = G[10];
  float G11 = G[11];
  float currAngle;
  float destAngle;
  float angleDiff;
  float distance;
  float rotation;

  // Calculate the angle off of the Z+ axis currently facing
  currAngle = atan2( F2, F10 );

  // Calculate the angle off of the Z+ axis to end facing
  destAngle = atan2( G3-F3, G11-F11 );
  
  NumOut( 0, LCD_LINE1, currAngle * _DEG_PER_RAD );
  NumOut( 0, LCD_LINE2, destAngle * _DEG_PER_RAD );

  // Convert both destination and current angles to "positive" angles, can be
  // > 180 degrees
  if ( destAngle < 0 )
    destAngle = _RAD_PER_CIRCLE + destAngle;
  if ( currAngle < 0 )
    currAngle = _RAD_PER_CIRCLE + currAngle;
  
  angleDiff = destAngle - currAngle;

  NumOut( 0, LCD_LINE3, angleDiff * _DEG_PER_RAD );

  if ( currAngle < destAngle )
    if ( currAngle + (_RAD_PER_CIRCLE / 2) < destAngle )
      angleDiff = -(_RAD_PER_CIRCLE - angleDiff);
  else if ( destAngle < currAngle )
    if ( destAngle + (_RAD_PER_CIRCLE / 2) < currAngle )
      angleDiff = -(_RAD_PER_CIRCLE - angleDiff);

  NumOut( 0, LCD_LINE4, angleDiff * _DEG_PER_RAD );

  // Calculate then walk the robot to G's location
  _3D_distance( F, G, distance );
  NumOut( 0, LCD_LINE5, distance );
  NumOut( 0, LCD_LINE6, distance / CM_PER_STEP );
  
  // Turn robot toward destination
  Rotate( angleDiff * _DEG_PER_RAD, BOT_ROT_SPD );
  
  // distance is the number of cm to move, coordinate axes are units of cm.
  Step( (distance / CM_PER_STEP), BOT_WALK_SPD );
  
  // Update the robot's current frame to reflect the rotation toward the destination
  float GCopy[12];
  GCopy = G;
  _3D_rot_y( GCopy, angleDiff, G );
}

// Move from one reference frame to another, walking backward
void RMove( float F[], float G[] )
{

}

