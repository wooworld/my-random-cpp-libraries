// BEGINNING OF FILE ----------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
/// @file TSP.cpp
/// @author Gary Steelman
/// @edit 24 Jan 2010
/// @brief Function definitions for the uniform cost tree search algorithm.
/// @note Assignment 2.
///////////////////////////////////////////////////////////////////////////////

#include "TSP.h"
#include "vector.h"
#include "state.h"
#include "search_node.h"
//#include <vector>
#include <cstdlib>
#include <functional>
#include <queue>
#include <ctime>
#include <cfloat>
#include <set>

using namespace std;

TSP::TSP():m_num_cities(0), m_total_distance(0), m_changed(true), m_graph_min(0) {}

TSP::TSP( const Matrix<double>& m ):m_graph(m), m_total_distance(0), m_changed(true) 
{
  srand( time( NULL ) ); 
  m_num_cities = m.width();
  set_graph_min( m );
}

const Matrix<double>& TSP::graph() const 
{  
  return m_graph; 
}

unsigned int TSP::num_cities() const 
{
  return m_num_cities;  
}

void TSP::set_graph( const Matrix<double>& m ) 
{

  srand( time( NULL ) ); 
  m_graph = m;
  m_num_cities = m.width();
  
  m_total_distance = 0;
  m_changed = true;
  
  return;  
}

void TSP::solve_UCGS() 
{
  //We'll only recalculate the solution if we haven't done it already
  if ( m_changed == true )
  {
    //For holding the nodes of the search
    priority_queue<search_node, deque<search_node>, greater<search_node> > frontier;
    
    //For holding nodes already expanded on
    deque<search_node> explored;
    
    //Seed the search tree
    srand( time( NULL ) ); 
    State initState( m_graph.width(), rand()%m_num_cities );
    search_node root( initState, 0 );
    root.m_path.push_back( initState.location() );
    search_node curr_node = root;
    
    //Set the first node
    frontier.push( root );
    
    //Holds the search nodes generated by the successor function
    deque<search_node> avail;
    
    while ( !frontier.empty() )
    { 
      //Grab the node at the top
      curr_node = frontier.top();
      
      //If it's a goal we're done
      if ( is_goal( curr_node ) )
        break;
      
      //Otherwise we'll need to generate more successors from it
      frontier.pop();
      avail.clear();
      successor( curr_node, avail );
      
      //In the case we've reached a state where all cities have been visited
      if ( avail.empty() )
      {
        avail.push_back( curr_node );
        avail.back().m_path.push_back( curr_node.m_path[0] );
        avail.back().set_cost( curr_node.cost() + m_graph[curr_node.m_path[0]][curr_node.get_state().location()] );
        avail.back().get_state().set_location( curr_node.m_path[0] );
      }
     
      explored.push_back( curr_node );

      bool append = true;
      
      //Push all generated States onto the search queue, but only if we
      //haven't seen them before. Takes time, but stops the algorithm from
      //using gigabytes of memory.
      for ( unsigned int i = 0; i < avail.size(); i++ ) {
      
        append = true;
        
        for ( unsigned int j = 0; j < explored.size(); j++ ) {
        
          if ( avail[i].get_state() == explored[j].get_state() )
            append = false;
        }
        
        if ( append )
          frontier.push( avail[i] );
      }
    } 
    
    m_solution = curr_node.m_path;
    m_total_distance = curr_node.cost();
    m_changed = false;
  }

  return;
}

void TSP::solve_ILTS()
{
  //We'll only recalculate the solution if we haven't done it already
  if ( m_changed == true )
  {
    //For holding the nodes of the search
    //puts the node with the largest path cost on the top
    priority_queue<search_node, deque<search_node>, greater<search_node> > frontier;
    
    //Holds the search nodes generated by the successor function
    deque<search_node> avail;
    
    //Seed the search tree
    srand( time( NULL ) ); 
    State initState( m_graph.width(), rand()%m_num_cities );
    search_node root( initState, 0 );
    root.m_path.push_back( initState.location() );
    search_node curr_node = root;
    
    // 1
    double MAXPATHCOST = 0;
    bool GOALFOUND = false;
    
    while ( !GOALFOUND )
    {
      // 2
      double NEXTPATHCOST = DBL_MAX;

      //Set the first node
      // 3
      frontier.push( root );
      
      // 10
      while ( !frontier.empty() )
      { 
        //Grab the node at the top
        // 4
        curr_node = frontier.top();
        
        // 6
        //If it's a goal we're done
        if ( is_goal( curr_node ) )
        {
          GOALFOUND = true;
          break;
        }
        
        // 5
        //Otherwise we'll need to generate more successors from it
        frontier.pop();
        avail.clear();
        
        // 7
        successor( curr_node, avail );
        
        //In the case we've reached a state where all cities have been visited
        if ( avail.empty() )
        {
          avail.push_back( curr_node );
          avail.back().m_path.push_back( curr_node.m_path[0] );
          avail.back().set_cost( curr_node.cost() + m_graph[curr_node.m_path[0]][curr_node.get_state().location()] );
          avail.back().get_state().set_location( curr_node.m_path[0] );
        }

        for ( unsigned int i = 0; i < avail.size(); i++ )
        {
          // 8
          if ( avail[i].cost() > MAXPATHCOST )
          {
            if ( NEXTPATHCOST > avail[i].cost() )
            {
              NEXTPATHCOST = avail[i].cost();           
            }
          // 9
          }
          else
          {
            frontier.push( avail[i] );
          }
        }  
        // 10
      }
      
      // 11
      MAXPATHCOST = NEXTPATHCOST;
    }
    
    m_solution = curr_node.m_path;
    m_total_distance = curr_node.cost();
    m_changed = false;
  }

  return;
}

void TSP::solve_BiASGS()
{
  //We'll only recalculate the solution if we haven't done it already
  if ( m_changed == true )
  {
    //For holding the nodes of the search
    multiset<search_node, less<search_node> > f_frontier;
    multiset<search_node, less<search_node> > b_frontier;
    deque<search_node> explored;
    
    //Seed the forward search
    srand( time( NULL ) ); 
    State f_initState( m_graph.width(), rand()%m_num_cities );
    f_initState.set_unvisited( f_initState.location() );
    search_node f_root( f_initState, 0 );
    f_root.m_path.push_back( f_initState.location() );
    
    f_frontier.insert( f_root );
    
    //Seed the backward search. 
    search_node b_root = f_root;
    for ( unsigned int i = 0; i < m_num_cities; i++ )
      b_root.get_state().set_visited( i );
    b_frontier.insert( b_root );
    
    //For actually expanding and such
    search_node f_node = f_root;
    search_node b_node = b_root;
    
    //Holds the search nodes generated by the *cessor function
    deque<search_node> f_avail;
    deque<search_node> b_avail;
    
    while ( !f_frontier.empty() )
    { 
      //Run through both frontiers to do a check for if a path has been found
      if ( is_BiASGS_goal( f_node, b_frontier ) )
        break;
      
      //If not we need to continue on
      f_node = *f_frontier.begin();
      b_node = *b_frontier.begin();
      
      //Continue forward search
      f_frontier.erase( f_frontier.begin() );
      f_avail.clear();
      successor( f_node, f_avail );
      
      //Continue backward search
      b_frontier.erase( b_frontier.begin() );
      b_avail.clear();
      predecessor( b_node, b_avail );

      explored.push_back( f_node );
      explored.push_back( b_node );

      bool append = true;
      
      //Push all successors and predecessors into their respective frontiers
      //but only if they aren't in the explored set already
      //Gogo graph search!
      //forward frontier search
      for ( unsigned int i = 0; i < f_avail.size(); i++ ) 
      {
        append = true;
        
        for ( unsigned int j = 0; j < explored.size(); j++ ) 
        {
          if ( f_avail[i].get_state() == explored[j].get_state() )
          {
            
            append = false;
            break;
          }
        }
        
        if ( append )
        {
          f_frontier.insert( f_avail[i] );
        }
      }
      
      //backward frontier search
      for ( unsigned int i = 0; i < b_avail.size(); i++ ) 
      {
        append = true;
        
        for ( unsigned int j = 0; j < explored.size(); j++ ) 
        {
          if ( b_avail[i].get_state() == explored[j].get_state() )
          {
            append = false;
            break;
          }
        }
        
        if ( append )
        {
          b_frontier.insert( b_avail[i] );
        }
      }      
    } 
    
    search_node f_node_plus;
    multiset<search_node>::iterator it;
    
    //Find the node that made is complete the goal check
    for ( it = b_frontier.begin(); it != b_frontier.end(); it++ )
    {
      if ( (*it).get_state() == f_node.get_state() )
      {
        f_node_plus = *it;
        break;
      }
    }
    
    m_total_distance = f_node.cost() + f_node_plus.cost();
    m_solution = f_node.m_path;
    
    //We've stored f_node's path as part of the solution, need to get the other
    //half from f_node_plus
    if ( f_node_plus.m_path.size() > 0 )
    {
      for ( unsigned int i = f_node_plus.m_path.size()-2; i > 0; i-- )
      {
        m_solution.push_back( f_node_plus.m_path[i] );
      }
    }
    
    m_solution.push_back( m_solution[0] );
    
    m_changed = false;
  }

  return;
}

void TSP::successor( const search_node& iNode, deque<search_node>& avail ) 
{   
  //For each city in the current state
  for ( unsigned long int i = 0; i < m_num_cities; i++ )
  {
    //If that city has not been visited
    //if ( !iNode.get_state().get_visited()[i] )
    if ( !iNode.get_state().get_visited()[i] && (i != iNode.m_path[0]) )
    {
      //Then push it into the list of available states to move to
      avail.push_back( iNode );
      
      //And update it to reflect what would happen after we move there
      avail.back().get_state().set_visited(i);
      avail.back().get_state().set_location(i);
      avail.back().m_path.push_back(i);
      avail.back().set_cost( iNode.cost() + m_graph[iNode.get_state().location()][avail.back().get_state().location()] + h_min_graph() );
    }
  }
  
  return;
}

void TSP::predecessor( const search_node& iNode, deque<search_node>& avail ) 
{
  //Make a copy of the current node
  search_node updated_node = iNode;
  
  //Set that node's location to unvisited (note: unreachable state!)
  updated_node.get_state().set_unvisited( updated_node.get_state().location() );
  
  //For each city in the node
  for ( unsigned int i = 0; i < m_num_cities; i++ )
  {
    //If that city is visited already
    if ( updated_node.get_state().get_visited()[i] )
    {
      avail.push_back( updated_node );
      avail.back().get_state().set_location(i);
      avail.back().m_path.push_back(i);
      avail.back().set_cost( iNode.cost() + m_graph[iNode.get_state().location()][avail.back().get_state().location()] + h_min_graph() );
    }
  }
  
  return;
}

const Vector<unsigned int>& TSP::get_solution() const 
{
  return m_solution;
}

double TSP::dist_traveled() const 
{
  return m_total_distance; 
}

//Returns if the state is a goal state
bool TSP::is_goal( const search_node& s ) const
{
  //If we aren't in the initial city, there's no way we're done
  if ( s.get_state().location() != s.m_path[0] )
    return false;  
  
  //Check each city for visited status
  for ( unsigned long int i = 0; i < m_num_cities; i++ )
    if ( s.get_state().get_visited()[i] == false )
      return false;
  
  return true;
}

bool TSP::is_BiASGS_goal( const search_node& s, const multiset<search_node, less<search_node> >& frontier )
{
  multiset<search_node>::iterator it;
  for ( it = frontier.begin(); it != frontier.end(); it++ )
  {
    if ( s.get_state() == (*it).get_state() )
    {
      return true;
    }
  }
    
  return false;
}

double TSP::h_straight_line( const search_node& s )
{
  //straight line distance from initial location to current location
  
  return m_graph[s.m_path[0]][s.get_state().location()];
}

double TSP::h_MST( const search_node& s )
{
  //note: only generate the MST for nodes that matter. So for a forward search
  //only generate a MST between all of the unvisited cities. 
  
  return 0;
}

double TSP::h_min_graph()
{
  return m_graph_min;
}

void TSP::set_graph_min( const Matrix<double>& m )
{
  m_graph_min = m[0][0];
  
  for ( unsigned int i = 0; i < m.height(); i++ )
    for ( unsigned int j = 0; j < i; j++ )
      if ( m_graph_min > m[i][j] )
        m_graph_min = m[i][j];
  
  return;
}

// END OF FILE ----------------------------------------------------------------
