/* 
  @file _3DFrame.c
  @auth Gary Steelman
  @desc The function definitions for a 3D Frame to be used with the 
    Lego Mindstorm NXT 2.0 kit.
  @edit 16 Mar 2011
*/

safecall void _3D_Init( _3DFrame& F )
{
  F.m[0]  = 1.0;
  F.m[1]  = 0.0;
  F.m[2]  = 0.0;
  F.m[3]  = 0.0;
  F.m[4]  = 0.0;
  F.m[5]  = 1.0;
  F.m[6]  = 0.0;
  F.m[7]  = 0.0;
  F.m[8]  = 0.0;
  F.m[9]  = 0.0;
  F.m[10] = 1.0;
  F.m[11] = 0.0;
  
  return;
}

safecall void _3D_Destroy( _3DFrame& F )
{
}

safecall void _3D_Copy( _3DFrame& A, const _3DFrame& B )
{
  A.m[0]  = B.m[0];
  A.m[1]  = B.m[1];
  A.m[2]  = B.m[2];
  A.m[3]  = B.m[3];
  A.m[4]  = B.m[4];
  A.m[5]  = B.m[5];
  A.m[6]  = B.m[6];
  A.m[7]  = B.m[7];
  A.m[8]  = B.m[8];
  A.m[9]  = B.m[9];
  A.m[10] = B.m[10];
  A.m[11] = B.m[11];
}

void _3D_Print( const _3DFrame& F )
{
  for ( uint8 i = 0; i < 12; i++ )
  {
    printf( "% 10.3f ", m_data[i] );
    
    if ( (i+1) % 4 == 0 )
      printf( "\n" );
  }

  printf( "\n" );
}

// TODO

_3DFrame _3D_Mult( const _3DFrame& A, const _3DFrame& B )
{
  _3DFrame temp;
  
  temp[0]  = 0.0;
  temp[1]  = 0.0;
  temp[2]  = 0.0;
  temp[3]  = 0.0;
  temp[4]  = 0.0;
  temp[5]  = 0.0;
  temp[6]  = 0.0;
  temp[7]  = 0.0;
  temp[8]  = 0.0;
  temp[9]  = 0.0;
  temp[10] = 0.0;
  temp[11] = 0.0;
  
  return temp;
}

safecall void _3D_set_rot_x( _3DFrame& F, sfloat32 alpha )
{
  sfloat32 sa = sin( alpha );
  sfloat32 ca = cos( alpha );
  
  F.m[0]  = 1.0;
  F.m[1]  = 0.0;
  F.m[2]  = 0.0;
  F.m[4]  = 0.0;
  F.m[5]  = ca;
  F.m[6]  = -1.0 * sa;
  F.m[8]  = 0.0;
  F.m[9]  = sa;
  F.m[10] = ca;
  
  return;
}

safecall void _3D_set_rot_y( _3DFrame& F, sfloat32 beta )
{
  sfloat32 sb = sin( beta );
  sfloat32 cb = cos( beta );
  
  F.m[0]  = cb;
  F.m[1]  = 0.0;
  F.m[2]  = sb;
  F.m[4]  = 0.0;
  F.m[5]  = 1.0;
  F.m[6]  = 0.0;
  F.m[8]  = -1.0 * sb;
  F.m[9]  = 0.0;
  F.m[10] = cb;
  
  return;
}

safecall void _3D_set_rot_z( _3DFrame& F, sfloat32 gamma )
{
  sfloat32 sg = sin( gamma );
  sfloat32 cg = cos( gamma );
  
  F.m[0]  = cg;
  F.m[1]  = -1.0 * sg;
  F.m[2]  = 0.0;
  F.m[4]  = sg;
  F.m[5]  = cg;
  F.m[6]  = 0.0;
  F.m[8]  = 0.0;
  F.m[9]  = 0.0;
  F.m[10] = 1.0;
  
  return;
}

safecall void _3D_set_x( _3DFrame& F, sfloat32 x )
{
  F.m[3] = x;

  return;
}

safecall void _3D_set_y( _3DFrame& F, sfloat32 y )
{
  F.m[7] = y;
  
  return;
}

safecall void _3D_set_z( _3DFrame& F, sfloat32 z )
{
  F.m[11] = z;
  
  return;
}

safecall void _3D_set_loc  ( _3DFrame& F,  sfloat32 x, sfloat32 y, sfloat32 z )
{
  F.m[3]  = x;
  F.m[7]  = y;
  F.m[11] = z;
  
  return;
}

_3DFrame _3D_rot_x( _3DFrame& F, sfloat32 alpha )
{
  _3DFrame temp;
  
  _3D_set_rot_x( temp, alpha );
  
  return ( temp * F );
}

_3DFrame _3D_rot_y( _3DFrame& F, sfloat32 beta )
{
  _3DFrame temp;
  
  _3D_set_rot_y( temp, beta );
  
  return ( temp * F );
}

_3DFrame _3D_rot_z( _3DFrame& F, sfloat32 gamma )
{
  _3DFrame temp;
  
  _3D_set_rot_z( temp, gamma );
  
  return ( temp * F );
}

_3DFrame _3D_translate( _3DFrame& F, sfloat32 x, sfloat32 y, sfloat32 z )
{
  _3DFrame temp;
  
  temp.m[3]  = F.m[0]*x + F.m[1]*y + F.m[2]*z + F.m[3];
  temp.m[7]  = F.m[4]*x + F.m[5]*y + F.m[6]*z + F.m[7];
  temp.m[11] = F.m[8]*x + F.m[9]*y + F.m[10]*z + F.m[11];
  
  return temp;
}

safecall void _3D_clear_rot( _3DFrame& F )
{
  F.m[0]  = 0.0;
  F.m[1]  = 0.0;
  F.m[2]  = 0.0;
  F.m[4]  = 0.0;
  F.m[5]  = 0.0;
  F.m[6]  = 0.0;
  F.m[8]  = 0.0;
  F.m[9]  = 0.0;
  F.m[10] = 0.0;

  return;
} 

safecall void _3D_clear_loc( _3DFrame& F )
{
  F.m[3]  = 0.0;
  F.m[7]  = 0.0;
  F.m[11] = 0.0;

  return;
}